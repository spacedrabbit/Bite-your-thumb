//
//  UIImage+Extensions.swift
//  BYT
//
//  Created by Louis Tur on 2/14/24.
//  Copyright Â© 2024 AccessLite. All rights reserved.
//

import UIKit

extension UIImage {
	
	func resized(to size: CGSize) -> UIImage? {
		UIGraphicsBeginImageContextWithOptions(size, false, 0.0)
		draw(in: CGRect(origin: .zero, size: size))
		let newImage = UIGraphicsGetImageFromCurrentImageContext()
		UIGraphicsEndImageContext()
		return newImage
	}
	
	/**
	 Scales an image to a specific width with respect to aspect ratio. The width
	 should be provided in points, not pixels.
	 
	 */
	public func resized(toWidth width: CGFloat) -> UIImage? {
		guard self.size.width > 0.0 else { return nil }
		let ratio = width / self.size.width
		let newHeight = self.size.height * ratio
		UIGraphicsBeginImageContextWithOptions(CGSize(width: width, height: newHeight), false, self.scale)
		self.draw(in: CGRect(x: 0.0, y: 0.0, width: width, height: newHeight))
		let newImage = UIGraphicsGetImageFromCurrentImageContext()
		UIGraphicsEndImageContext()
		return newImage
	}
	
	/**
	 Scales an image to a specific height with respect to aspect ratio. The height
	 should be provided in points, not pixels.
	 
	 */
	public func resized(toHeight height: CGFloat) -> UIImage? {
		guard self.size.height > 0.0 else { return nil }
		let ratio = height / self.size.height
		let newWidth = self.size.width * ratio
		UIGraphicsBeginImageContextWithOptions(CGSize(width: newWidth, height: height), false, self.scale)
		self.draw(in: CGRect(x: 0.0, y: 0.0, width: newWidth, height: height))
		let newImage = UIGraphicsGetImageFromCurrentImageContext()
		UIGraphicsEndImageContext()
		return newImage
	}
	
	/**
	 Rotates an image.
	 
	*/
	public func rotated(by degrees: CGFloat) -> UIImage? {
		guard let cgImage = self.cgImage else { return nil }
		
		let angle = Measurement<UnitAngle>(value: Double(degrees), unit: .degrees)
		let radians = CGFloat(angle.converted(to: .radians).value)
		let transform = CGAffineTransform(rotationAngle: radians)
		var rect = CGRect(origin: .zero, size: self.size).applying(transform)
		rect.origin = .zero
		
		let renderer = UIGraphicsImageRenderer(size: rect.size)
		return renderer.image { renderContext in
			renderContext.cgContext.translateBy(x: rect.midX, y: rect.midY)
			renderContext.cgContext.rotate(by: radians)
			renderContext.cgContext.scaleBy(x: 1.0, y: -1.0)
			
			let drawRect = CGRect(origin: CGPoint(x: -self.size.width / 2.0, y: -self.size.height / 2.0), size: self.size)
			renderContext.cgContext.draw(cgImage, in: drawRect)
		}
	}
	
	/**
	 Generates an image given text, a font, text color, background color and size
	 
	 */
	public static func text(_ text: String, font: UIFont, textColor: UIColor = .white, backgroundColor: UIColor? = nil, size: CGSize) -> UIImage? {
		let label = UILabel(frame: CGRect(x: 0.0, y: 0.0, width: size.width, height: size.height))
		label.center = CGPoint(x: size.width / 2.0, y: size.height / 2.0)
		label.textAlignment = .center
		label.font = font
		label.textColor = textColor
		label.backgroundColor = backgroundColor
		label.text = text
		
		UIGraphicsBeginImageContextWithOptions(size, false, UIScreen.main.scale)
		if let currentContext = UIGraphicsGetCurrentContext() {
			label.layer.render(in: currentContext)
			let textImage = UIGraphicsGetImageFromCurrentImageContext()
			UIGraphicsEndImageContext()
			return textImage
		}
		return nil
	}
	
	/**
	 Generates a stretchable image with a fill color, corner radius, stroke color, and stroke width. "Stretchable"
	 means that the resulting image can be used at any size without corner radius or stroke distortion. The resulting
	 image is generally very small. For example, an image with no corner radius or stroke is only 1px. An image with
	 a 5px corner radius and no stroke would only be 11px x 11px (corner radius + 1px + corner radius, square).
	 
	 Images generated by this function are, by default, stored in an LRU cache to minimize overhead. This can be
	 diabled by explicitly setting `cache = false`.
	 
	 */
	public static func stretchable(withFill fill: UIColor, cornerRadius: CGFloat = 0.0, stroke: UIColor? = nil, strokeWidth: CGFloat = 0.0, cache: Bool = true) -> UIImage? {
		var key: String = "\(fill.hashValue)_\(cornerRadius)"
		if let stroke = stroke, strokeWidth > 0.0 {
			key += "_\(stroke.hashValue)_\(strokeWidth)"
		}
		
		if let image = ImageAssetsCache.shared.imageForKey(key) {
			return image
		}
		
		let minimumEdge: CGFloat = (cornerRadius * 2.0) + (strokeWidth * 2.0) + 1.0
		let rect: CGRect = CGRect(x: 0.0, y: 0.0, width: minimumEdge, height: minimumEdge)
		let bezierPath: UIBezierPath = UIBezierPath(roundedRect: rect, cornerRadius: cornerRadius)
		
		UIGraphicsBeginImageContextWithOptions(rect.size, false, UIScreen.main.scale)
		bezierPath.addClip()
		fill.setFill()
		bezierPath.fill()
		if let stroke = stroke, strokeWidth > 0.0 {
			bezierPath.lineWidth = strokeWidth
			stroke.setStroke()
			bezierPath.stroke()
		}
		let image = UIGraphicsGetImageFromCurrentImageContext()
		UIGraphicsEndImageContext()
		
		let inset: CGFloat = cornerRadius + strokeWidth
		let generatedImage = image?.resizableImage(withCapInsets: UIEdgeInsets(top: inset, left: inset, bottom: inset, right: inset))
		
		if let generatedImage = generatedImage, cache {
			ImageAssetsCache.shared.setImage(generatedImage, for: key)
		}
		
		return generatedImage
	}
	
	/**
	 Generates a circular image with a fill color, corner radius, stroke color, and stroke width.
	 
	 */
	public static func circular(withDiameter diameter: CGFloat, fill: UIColor, stroke: UIColor? = nil, strokeWidth: CGFloat = 0.0) -> UIImage? {
		let rect = CGRect(x: 0.0, y: 0.0, width: diameter, height: diameter)
		let bezierPath = UIBezierPath(ovalIn: rect)
		
		UIGraphicsBeginImageContextWithOptions(rect.size, false, UIScreen.main.scale)
		bezierPath.addClip()
		fill.setFill()
		bezierPath.fill()
		if let stroke = stroke, strokeWidth > 0.0 {
			bezierPath.lineWidth = strokeWidth
			stroke.setStroke()
			bezierPath.stroke()
		}
		let image = UIGraphicsGetImageFromCurrentImageContext()
		UIGraphicsEndImageContext()
		
		return image
	}
	
	/// this is a helper to overlay an image with a color.
	/// This is NOT tint, which uses the image as a template. Instead, this multiplies the original image with the color
	public func overlayWithColor(_ color: UIColor) -> UIImage? {
		let imageRect = CGRect(x: 0, y: 0, width: self.size.width, height: self.size.height)

		UIGraphicsBeginImageContextWithOptions(self.size, false, 0)
		if let context = UIGraphicsGetCurrentContext() {
			context.setFillColor(color.cgColor)
			context.fill(imageRect)

			// multiple the colors of the destination by source samples
			self.draw(in: imageRect, blendMode: .multiply, alpha: 1)
			// draw the destination image in the source alpha
			self.draw(in: imageRect, blendMode: .destinationIn, alpha: 1)
		}
		
		let result = UIGraphicsGetImageFromCurrentImageContext()
		UIGraphicsEndImageContext()
		return result
		
	}
}

// MARK: - ImageAssetsCache

/**
 This class handles the caching and retrieval of tinted and stretchable images.
 We have to use a queue in order to prevent read-write issues, see DateFormatterCache
 */
class ImageAssetsCache {
	static let shared = ImageAssetsCache()
	private var cache = LRUCache<String, UIImage>(capacity: 50)
	private let queue = DispatchQueue(label: "com.zola.imageAssetsCache", attributes: .concurrent)
	
	internal func imageForKey(_ key: String) -> UIImage? {
		var image: UIImage?

		/**
		 Read the value via the queue. We must do this synchonously because we need to return the value.
		 The queue will allow for multiple reads to occur on multiple threads concurrently.
		 */
		queue.sync { [weak self] in
			image = self?.cache[key]
		}
		
		return image
	}
	
	internal func setImage(_ image: UIImage?, for key: String) {
		queue.async(flags: .barrier) { [weak self] in
			self?.cache[key] = image
		}
	}
}
